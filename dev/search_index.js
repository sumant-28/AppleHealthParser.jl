var documenterSearchIndex = {"docs":
[{"location":"tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/#Placeholder-text","page":"Tutorials","title":"Placeholder text","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"We use the function main:","category":"page"},{"location":"approach/#The-Method","page":"Method","title":"The Method","text":"","category":"section"},{"location":"approach/","page":"Method","title":"Method","text":"There is no one correct way to parse this document. Many have been done before. The first and second examples highlighted in R used the DOM API in the R XML parser module and as will be explained in this documentation does not seem scalable for years worth of data. The first and second examples in Python2 and Python3 respectively are instructive and use a parser that doesn't load the entire file onto local memory. Those analyses overlap with what is presented in this documentation and source code but there are also some differences in approach. ","category":"page"},{"location":"approach/#How-the-Data-is-Structured","page":"Method","title":"How the Data is Structured","text":"","category":"section"},{"location":"approach/","page":"Method","title":"Method","text":"Unlike other XML documents where the data is stored in the elements individually Apple has decided to store the strings containing data as attributes. There is also a nesting structure where elements of a certain title can have elements that themselves follow the same structure of data contained in attributes. The three types of nodes for which nesting can occur have the following titles \"ActivitySummary\", \"Record\", \"Workout\". The full structure of the file is laid out in the DTD syntax.","category":"page"},{"location":"approach/#A-single-flat-table-is-not-a-suitable-export-format-for-this-data","page":"Method","title":"A single flat table is not a suitable export format for this data","text":"","category":"section"},{"location":"approach/","page":"Method","title":"Method","text":"It may be reasonable to think that because this document contains a series of nodes which each contain a set of attributes to create a dictionary for each node and convert that to appear all in the same dataframe. The image below shows some of the attributes are shared in common with three main nodes","category":"page"},{"location":"approach/","page":"Method","title":"Method","text":"(Image: subet1)","category":"page"},{"location":"approach/","page":"Method","title":"Method","text":"While there is some overlap in fields this visual shows that the resulting table of a simple export will have a lot of sparsity which is not efficient for storing larger data. Apple also deliberately seems to make some fields with similar properties have different names on purpose like in the naming convention of the date fields.","category":"page"},{"location":"approach/#The-Processing-Method-needs-to-scale-with-Big-Data","page":"Method","title":"The Processing Method needs to scale with Big Data","text":"","category":"section"},{"location":"approach/","page":"Method","title":"Method","text":"The most convenient and efficient method to extract data from a .xml file for analysis is to use the DOM API along with XPATH ","category":"page"},{"location":"approach/","page":"Method","title":"Method","text":"(Image: subet1)","category":"page"},{"location":"approach/","page":"Method","title":"Method","text":"The following code snippet illustrates how any piece of data can be extracted as a vector and then used to make a graph or used for a regression","category":"page"},{"location":"approach/","page":"Method","title":"Method","text":"using EzXML\nfilename = joinpath(dirname(pathof(AppleHealthParser)), \"..\", \"test\", \"data\", \"reconstructed.xml\")\ndoc = readxml(filename)\nnodecontent.(findall(\"//Record//@value\", doc))","category":"page"},{"location":"approach/","page":"Method","title":"Method","text":"This grabs all the \"value\" values for each Record element in the file. Any other key is similarly accessible. The language this is written in is of course Julia but XPATH syntax is similar in other scientific computing languages. In user testing loading the data into local memory to facilitate this is not not reasonable for larger amounts of data that exceed 100,000 observations or so. Therefore the more convoluted process is followed in the flowchart above.","category":"page"},{"location":"approach/#The-three-main-tags-for-which-elements-can-be-nested-are-the-export-object-names","page":"Method","title":"The three main tags for which elements can be nested are the export object names","text":"","category":"section"},{"location":"approach/","page":"Method","title":"Method","text":"Whether it is a vector of dictionaries or DataFrames or .csv files it makes the most sense to export the data separated by whether it is a \"Record\", \"ActivitySummary\" or \"Workout\". This is because Apple has decided to nest metadata in these elements. The nested metadata sometimes makes sense out of this context but frequently does not.","category":"page"},{"location":"overview/#Implementation","page":"Implementation","title":"Implementation","text":"","category":"section"},{"location":"overview/","page":"Implementation","title":"Implementation","text":"Throughout this document reference will be made to a specific XML file as an illustrative example. This is reconstructed from an earlier example in Python2 which is publicly accessible at time of writing. The author will also intersperse graphs from his own exploration in order to make points.","category":"page"},{"location":"overview/#Streaming-Parser","page":"Implementation","title":"Streaming Parser","text":"","category":"section"},{"location":"overview/","page":"Implementation","title":"Implementation","text":"As mentioned earlier in this documentation the best XML parser to handle big data is a streaming API that doesn't load all the data into memory. There are currently two available in Julia in the EzXML.jl module with Streaming API and the XML.jl module with LazyNode. The XML.jl module is preferred because it allows the user to access the nesting structure rather than just the contents of the current node.","category":"page"},{"location":"overview/#Implementation-Details","page":"Implementation","title":"Implementation Details","text":"","category":"section"},{"location":"overview/","page":"Implementation","title":"Implementation","text":"There are two exportable functions depending on if the user wants to handle the inherently unstructured metadata. If the metadata is to be appended as attributes to the nesting element it is done in the following way using the example XML file as a guide.","category":"page"},{"location":"overview/","page":"Implementation","title":"Implementation","text":"    <Record type=\"HKQuantityTypeIdentifierHeight\"\n            sourceName=\"Health\"\n            sourceVersion=\"9.2\"\n            unit=\"cm\"\n            creationDate=\"2016-01-02 09:45:10 +0100\"\n            startDate=\"2016-01-02 09:44:00 +0100\"\n            endDate=\"2016-01-02 09:44:00 +0100\"\n            value=\"194\">\n     <MetadataEntry key=\"HKWasUserEntered\" value=\"1\"/>\n    </Record>","category":"page"},{"location":"overview/","page":"Implementation","title":"Implementation","text":"becomes","category":"page"},{"location":"overview/","page":"Implementation","title":"Implementation","text":"    <Record type=\"HKQuantityTypeIdentifierHeight\"\n            sourceName=\"Health\"\n            sourceVersion=\"9.2\"\n            unit=\"cm\"\n            creationDate=\"2016-01-02 09:45:10 +0100\"\n            startDate=\"2016-01-02 09:44:00 +0100\"\n            endDate=\"2016-01-02 09:44:00 +0100\"\n            value=\"194\"\n            MetadataEntry1key=\"HKWasUserEntered\"\n            MetadataEntry1value=\"1\"\n    </Record>","category":"page"},{"location":"overview/","page":"Implementation","title":"Implementation","text":"If the data is fixed width then the output format is a .csv file. If the metadata is included the data contained in the dictionaries is no longer fixed width and a simple export to .csv file is no longer feasible. While the example metadata above in the sample file is simple real life data frequently is not. ","category":"page"},{"location":"overview/#Recommended-Approach-After-Vector-of-Dictionaries-Is-Exported","page":"Implementation","title":"Recommended Approach After Vector of Dictionaries Is Exported","text":"","category":"section"},{"location":"overview/","page":"Implementation","title":"Implementation","text":"After splitting the data into \"Record\", \"ActivitySummary\" and \"Workout\" vectors it makes the most sense to split the \"Record\" and \"Workout\" vectors by the attribute \"sourceName\". This is because the data is structured differently and it is convenient to handle different types separately.","category":"page"},{"location":"overview/","page":"Implementation","title":"Implementation","text":"The metadata from Apple Watch under the \"Record\" element is frequently the instantaneous heart rate as a constant data stream for all hours of the day while the device is worn. This type of data is unstructured and inherently long. The export file could therefore be a long DataFrame or simply a vector of observations that ignores the Record element it is nested in because the date time is already universal.","category":"page"},{"location":"overview/","page":"Implementation","title":"Implementation","text":"On the other hand data from Withings relate to various body measurements with a fixed amount of observations each time a weighing scale is used. This data is inherently wide and makes more sense with a wide DataFrame. ","category":"page"},{"location":"overview/","page":"Implementation","title":"Implementation","text":"(Image: subet1)","category":"page"},{"location":"overview/","page":"Implementation","title":"Implementation","text":"(Image: subet1)","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Contents","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [AppleHealthParser]","category":"page"},{"location":"reference/#AppleHealthParser.AppleHealthParser","page":"Reference","title":"AppleHealthParser.AppleHealthParser","text":"Module for parsing Apple Health files.\n\n\n\n\n\n","category":"module"},{"location":"reference/#AppleHealthParser.attribute_meta-NTuple{4, Any}","page":"Reference","title":"AppleHealthParser.attribute_meta","text":"This function takes the vector of element attributes extracted using the XML parser and modifies it in place so that the parent elements are dictionaries containing keys and values from all the nested child elements appended as vectors.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AppleHealthParser.basic_export-Tuple{Any}","page":"Reference","title":"AppleHealthParser.basic_export","text":"This function takes the original XML file downloaded from Apple and converts the data into separate CSV files according to the procedure outlined in the documentation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AppleHealthParser.enhanced_metadata-Tuple{Any}","page":"Reference","title":"AppleHealthParser.enhanced_metadata","text":"This function takes the original XML file downloaded from Apple and creates separate collections of dictionaries for each parent node. The metadata is preserved as key value pairs appended to the original dictionaries.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AppleHealthParser.flatten_dictionaries-Tuple{Any}","page":"Reference","title":"AppleHealthParser.flatten_dictionaries","text":"This function takes a dictionary with nested vectors containing child elements and flattens the data resulting in a dictionary that only has keys and values.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AppleHealthParser.generate_csv-Tuple{Any, Any, Any}","page":"Reference","title":"AppleHealthParser.generate_csv","text":"This function takes the element tags, element attributes and names of parent nodes and generates a csv file for each parent node name.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AppleHealthParser.return_child_elements-Tuple{Any, Any, Any}","page":"Reference","title":"AppleHealthParser.return_child_elements","text":"This function returns the child element indices of the element attributes vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AppleHealthParser.return_child_elements_i-Tuple{Any, Any, Any}","page":"Reference","title":"AppleHealthParser.return_child_elements_i","text":"This function returns two outputs. The first are the indices of child elements from the  file which can be removed. The second output is the collection of indices which are parent elements for which child elements can be appended to the extracted dictionary.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = AppleHealthParser","category":"page"},{"location":"#AppleHealthParser","page":"Home","title":"AppleHealthParser","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for AppleHealthParser. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will be added to in later versions. The main functions to pay attention to are basic_export and enhanced_metadata. The former will export the data sans child elements to .CSV files because the data is reliably fixed width. With unstructured metadata of variable lines the conversion to tabular data of fixed width is no longer as simple. Therefore the data is left as  vectors of dictionaries separated by parent tag names.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
